The Dependency Inversion Principle (DIP) is the fifth SOLID principle of object-oriented design, introduced by Robert C. Martin. It states that:

High-level modules should not depend on low-level modules. Both should depend on abstractions.
Abstractions should not depend on details. Details should depend on abstractions.

In simpler terms, DIP emphasizes that both high-level (business logic) and low-level (implementation details) components should rely on interfaces or abstract classes rather than concrete implementations. This decouples modules, making systems more flexible, testable, and maintainable.
Key Concepts of DIP

High-Level Modules: Components that contain business logic or orchestrate the flow of the application.
Low-Level Modules: Components that handle specific tasks, such as data access, logging, or file operations.
Abstractions: Interfaces or abstract classes that define contracts without specifying implementation details.
Goal: Reduce tight coupling between modules, allowing changes to low-level details (e.g., switching a database) without affecting high-level logic.

In C#, DIP is commonly implemented using interfaces, abstract classes, and dependency injection (DI).

Common Techniques to Achieve DIP in C#

Interfaces: Define contracts that high-level and low-level modules depend on.
Abstract Classes: Use abstract classes when you need shared behavior in addition to a contract.
Dependency Injection: Pass dependencies via constructor injection, property injection, or method injection, often using DI containers like Microsoft.Extensions.DependencyInjection, Autofac, or Unity.
Service Locator Pattern: (Less preferred) Use a service locator to resolve dependencies, though this can hide dependencies and make code harder to follow.
Factory Pattern: Use factories to create instances of abstractions, decoupling object creation from usage.

Real-World Example
Imagine an e-commerce application with an OrderService (high-level module) that saves orders to a database. Without DIP, OrderService might directly depend on a concrete SqlDatabase class. If you later need to switch to a NoSqlDatabase, you’d have to modify OrderService. By applying DIP, you’d define an IDataStore interface, make OrderService depend on IDataStore, and inject either SqlDatabase or NoSqlDatabase at runtime, allowing seamless swapping without changing OrderService.
Common Signs of DIP Violation

Direct Instantiation: High-level modules create instances of low-level classes (e.g., new FileLogger()).
Tight Coupling: Changing a low-level module requires modifying high-level modules.
Hard-to-Test Code: Unit tests require real implementations of dependencies (e.g., a real database or file system).
Concrete Dependencies: Classes depend on concrete types rather than abstractions.